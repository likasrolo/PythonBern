import pandas as pd
from collections import Counter
import json

def list_action_clients(conseiller: str, fichier_xlsx: str):
    df = pd.read_excel(fichier_xlsx)
    df_filtered = df[df['CONSEILLER'] == conseiller]
    df_filtered = df_filtered[df_filtered['CODE ISIN'].notna()]

    results = []
    for portfolio in df_filtered['Portfolio'].unique():
        portfolio_data = df_filtered[df_filtered['Portfolio'] == portfolio]
        instruments_data = []
        for _, row in portfolio_data.iterrows():
            secteur = row.get('INSTRUMENT.1', 'N/A')
            if pd.isna(secteur): secteur = 'N/A'
            instrument = row.get('INSTRUMENT', 'N/A')
            if pd.isna(instrument): instrument = 'N/A'
            emmeteur = row.get('EMMETEUR', 'N/A')
            if pd.isna(emmeteur): emmeteur = 'N/A'
            instruments_data.append({
                'instrument': instrument,
                'emmeteur': emmeteur,
                'secteur': secteur
            })

        instruments_count = Counter(portfolio_data['INSTRUMENT.1'].dropna())
        countries_count = Counter(portfolio_data['EMMETEUR/PAYS DE RESIDENCE'].dropna())
        instruments_str = ', '.join([f"{k}({v})" for k, v in instruments_count.items()])
        countries_str = ', '.join([f"{k}({v})" for k, v in countries_count.items()])
        results.append({
            'Portfolio': portfolio,
            'INSTRUMENTS_DATA': instruments_data,
            'Countries_Summary': countries_str,
            'Instruments_Summary': instruments_str
        })

    df_results = pd.DataFrame(results)
    mask = df_results['INSTRUMENTS_DATA'].apply(len) <= 100
    clients_moins_ou_egal_100 = df_results[mask].reset_index(drop=True)
    return clients_moins_ou_egal_100

def grouped_clients_json(clients_moins_100, instrument_limit=100):
    idx = 0
    n = len(clients_moins_100)
    section_num = 1
    sections = []

    while idx < n:
        current_section = []
        current_count = 0

        while idx < n:
            client = clients_moins_100.iloc[idx]
            nb_instruments = len(client['INSTRUMENTS_DATA'])
            if current_count + nb_instruments > instrument_limit and current_section:
                break
            current_section.append(client)
            current_count += nb_instruments
            idx += 1

        section_dict = {
            "section": section_num,
            "total_instruments": current_count,
            "total_clients": len(current_section),  # NEW: number of clients in this section
            "clients": []
        }
        for client in current_section:
            numero_client = client['Portfolio']
            client_dict = {
                "client_number": numero_client,
                "instruments": client['INSTRUMENTS_DATA'],
                "instruments_summary": client['Instruments_Summary'],
                "countries_summary": client['Countries_Summary']
            }
            section_dict["clients"].append(client_dict)
        sections.append(section_dict)
        section_num += 1
    return sections

def json_file(conseiller, fichier_xlsx):
    try:
        clients_moins_100 = list_action_clients(
            conseiller,
            fichier_xlsx
        )
        sections = grouped_clients_json(clients_moins_100, instrument_limit=100)
        with open("../data/clients_sections.json", "w", encoding="utf-8") as f:
            json.dump(sections, f, ensure_ascii=False, indent=2)
        print("JSON file '../data/clients_sections.json' created successfully.")

    except FileNotFoundError:
        print("Erreur : Le fichier Excel n'a pas été trouvé")
    except Exception as e:
        print(f"Une erreur s'est produite : {str(e)}")

def count_sections_in_json(json_path):
    """
    Returns the number of sections in the JSON file generated by grouped_clients_json.
    Each section is an element in the top-level list.
    """
    with open(json_path, "r", encoding="utf-8") as f:
        sections = json.load(f)
    return len(sections)

def read_md_file(md_path):
    with open(md_path, "r", encoding="utf-8") as f:
        return f.read()

def read_json(path):
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    return data

def generate_prompt_for_section(json_path, section_idx):
    """
    Generate a clear LLM-friendly prompt string for the given section index from the JSON file.

    Args:
        json_path (str): Path to the JSON file (list of sections).
        section_idx (int): Index of the section (0-based).

    Returns:
        str: The formatted prompt string for the section.
    """
    with open(json_path, "r", encoding="utf-8") as f:
        sections = json.load(f)

    if not (0 <= section_idx < len(sections)):
        return f"Section {section_idx+1} does not exist in this file."

    section = sections[section_idx]
    prompt_lines = []
    prompt_lines.append(f"Section {section['section']} summary:")
    prompt_lines.append(f"Total instruments: {section['total_instruments']}")
    prompt_lines.append(f"Total clients: {section['total_clients']}")
    prompt_lines.append("")  # Empty line

    for client in section["clients"]:
        client_number = client["client_number"]
        prompt_lines.append(f"Client number: {client_number}")
        prompt_lines.append("Instruments for this client:")
        prompt_lines.append("| Instrument                        | Emmeteur                    | Secteur                              |")
        prompt_lines.append("|-----------------------------------|-----------------------------|--------------------------------------|")
        for inst in client["instruments"]:
            instrument = inst.get("instrument", "")[:33]
            emmeteur = inst.get("emmeteur", "")[:27]
            secteur = inst.get("secteur", "")[:36]
            prompt_lines.append(f"| {instrument:<33} | {emmeteur:<27} | {secteur:<36} |")
        # Add summaries if available
        if "instruments_summary" in client:
            prompt_lines.append(f"Instruments summary: {client['instruments_summary']}")
        if "countries_summary" in client:
            prompt_lines.append(f"Countries summary: {client['countries_summary']}")
        prompt_lines.append("")  # Blank line after each client


    return "\n".join(prompt_lines)

def prompt_association(titres, news_md_path, section_idx, json_path="../data/clients_sections.json"):
    """
    titres: list of newsletter titles (strings)
    news_md_path: path to the markdown file containing the newsletter summary
    section_idx: index of the section in the JSON
    json_path: path to the JSON file containing client data
    Returns: the complete formatted prompt as a string
    """
    extraction_client = generate_prompt_for_section(json_path, section_idx)
    newsletter_resume = read_md_file(news_md_path)


    prompt = f"""à partir de la liste des instruments d'un ou plusieurs clients et d'une newsletter , trouve les correspondances entre les instruments des clients et les titres de la newsletter.

voici la liste des instruments des clients : 

{extraction_client}

La newsletter entière pour un meilleur contexte : 
{newsletter_resume}

Voici la liste des titres de la newsletter: 
{titres}

Ta sortie se divise en deux parties : 
la première consiste à me renvoyer une liste avec les numéros de client associée correspondante aux titres. 
la seconde un résumer de 5 lignes maximum pour indiquer les correspondences trouvées. 
le tout séparer par des tirets "---".
(renvoie uniquement ce que je demande, la sortie sera analyser par python, des ajout peuvent fausser et casser la chaine d'automatisation).

Pour la liste : 
   - Elle aura en index i le numéro des clients correspondant au titre d'index i dans la liste des titres.
   - Pour les titres précis comme des actions/entreprises associe un numéro de client uniquement si il possède un instrument explicite à cette action entreprise. Pour les titres plus larges comme des secteurs ou pays associe les clients plus finement mais une correspondance forte forte est nécessaire.
 
Pour le résumer : Ne mentionne dans le résumé que les correspondances riches en contexte, en justifiant brièvement la pertinence de l’association. Pour les liens évidents (ex : action détenue = titre d’entreprise), ajoute uniquement le titre et l'instrument correspondant et n’indique rien pour les correspondances faibles ou absentes. Sois synthétique et factuel, sans extrapoler.

exemple de sortie : 
[['MC209710','MC987091'],[],[MC2907309],[],[],...]
--------
résumer des secteurs intéressant pour les clients
"""
    return prompt


def associate_titles_with_clients(json_path, titles):
    """
    Reads the JSON file at json_path, which contains "all_lists" (a list of lists of client numbers),
    and returns a list of [title, [client_numbers...]] for each title.

    - `titles`: list of newsletter titles, same order as in the prompt and as all_lists indices.
    - `json_path`: path to the JSON file with "all_lists".

    Returns:
        result: list of [title, [all client numbers from all sections for that index]]
    """
    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)
    all_lists = data["all_lists"]  # This is a list of lists, one per section

    # Zip all_lists to group by title index across all sections
    # Each element of grouped_lists will be a tuple of (section1_clients, section2_clients, ...) for title i
    grouped_lists = list(zip(*all_lists))

    result = []
    for idx, title in enumerate(titles):
        # Flatten all client lists for this title across sections and keep only unique client numbers
        clients = set()
        for client_group in grouped_lists[idx]:
            clients.update(client_group)
        result.append([title, sorted(clients)])
    return result

def prompt_final(titres, path_json, path_newsletter):
    newsletter = read_md_file(path_newsletter)
    commentaires = read_json(path_json)["all_summaries"]

    prompt =f"""
    A partir de la liste, qui associe les titres et les clients, et des commentaires sur les associations, personnalise la newsletter pour afficher uniquement les information nécessaire.
    Pour les titres précis comme des actions/entreprise, si il n'y a que ne serait ce qu'un seul numéro de client, considère que le titre est important. pour les titres plus large prend plus en compte les commentaires et le nombre de clients. 
    Ajoute les numéros client juste en dessous du titre en question. 
    Si il n'y a aucun clients associée à un titre, n'ajoute pas l'information dans la newletter.
    N'hésite pas à ajouter les commentaires si tu trouve qu'il sont pertinent en dessous des titres correspondant, tu peux résumer les commentaire au lieux de les ajouter tel quel.
    Vérifie la cohérence de l'ensemble de ton retours, il faut que ce soit fluide comme une newsletter normal, pas de liste avec des titres sans informations.
    Garde le contenus des titres dans le corps de la newsletter, si par exemple titresX à des clients, et dans la newsletter on a titreX agis sur cette portion fait ci et ça, on garde ces information dans la sortie.
    
    Voici la liste des titres avec les clients associées : 
    {titres}
    
    Voici les commentaire des associations des titres
    {commentaires}
    
    Voici la newsletter original en format MD 
    {newsletter}
    """
    return prompt

def extract_crm_portfolio():
    print("extract_crm_portfolio function is running")
    
if __name__ == "__main__":
    json_file('ROLLAND JEAN-MARC', '../data/CRM_clients.xlsx')